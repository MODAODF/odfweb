{"version":3,"sources":["webpack:///./node_modules/brace/mode/ruby.js"],"names":["ace","define","acequire","exports","module","oop","TextHighlightRules","constantOtherSymbol","token","regex","constantNumericHex","qString","qqString","tString","constantNumericFloat","RubyHighlightRules","instanceVariable","keywordMapper","this","$keywords","createKeywordMapper","$rules","next","onMatch","val","state","stack","nextState","length","unshift","shift","indexOf","push","defaultToken","stateName","value","currentState","tokens","split","splitRegex","type","rules","heredoc","indentedHeredoc","normalizeRules","inherits","Range","MatchingBraceOutdent","checkOutdent","line","input","test","autoOutdent","doc","row","match","getLine","column","openBracePos","findMatchingBracket","indent","$getIndent","replace","call","prototype","BaseFoldMode","FoldMode","getFoldWidgetRange","session","foldStyle","range","indentationBlock","re","startLevel","search","startColumn","maxRow","getLength","startRow","endRow","level","endColumn","getFoldWidget","prev","prevIndent","nextIndent","foldWidgets","TextMode","Mode","CstyleBehaviour","HighlightRules","$outdent","$behaviour","foldingRules","lineCommentStart","getNextLineIndent","tab","getTokenizer","getLineTokens","startingClassOrMethod","startingDoBlock","startingConditional","prevLine","getTabString","slice","remove","$id"],"mappings":"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","file":"rb-mode.bundle.js","sourcesContent":["ace.define(\"ace/mode/ruby_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\nvar constantOtherSymbol = exports.constantOtherSymbol = {\n    token : \"constant.other.symbol.ruby\", // symbol\n    regex : \"[:](?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?\"\n};\n\nvar qString = exports.qString = {\n    token : \"string\", // single line\n    regex : \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n};\n\nvar qqString = exports.qqString = {\n    token : \"string\", // single line\n    regex : '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'\n};\n\nvar tString = exports.tString = {\n    token : \"string\", // backtick string\n    regex : \"[`](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[`]\"\n};\n\nvar constantNumericHex = exports.constantNumericHex = {\n    token : \"constant.numeric\", // hex\n    regex : \"0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_(?=[0-9a-fA-F]))*\\\\b\"\n};\n\nvar constantNumericFloat = exports.constantNumericFloat = {\n    token : \"constant.numeric\", // float\n    regex : \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n};\n\nvar instanceVariable = exports.instanceVariable = {\n    token : \"variable.instance\", // instance variable\n    regex : \"@{1,2}[a-zA-Z_\\\\d]+\"\n};\n\nvar RubyHighlightRules = function() {\n\n    var builtinFunctions = (\n        \"abort|Array|assert|assert_equal|assert_not_equal|assert_same|assert_not_same|\" +\n        \"assert_nil|assert_not_nil|assert_match|assert_no_match|assert_in_delta|assert_throws|\" +\n        \"assert_raise|assert_nothing_raised|assert_instance_of|assert_kind_of|assert_respond_to|\" +\n        \"assert_operator|assert_send|assert_difference|assert_no_difference|assert_recognizes|\" +\n        \"assert_generates|assert_response|assert_redirected_to|assert_template|assert_select|\" +\n        \"assert_select_email|assert_select_rjs|assert_select_encoded|css_select|at_exit|\" +\n        \"attr|attr_writer|attr_reader|attr_accessor|attr_accessible|autoload|binding|block_given?|callcc|\" +\n        \"caller|catch|chomp|chomp!|chop|chop!|defined?|delete_via_redirect|eval|exec|exit|\" +\n        \"exit!|fail|Float|flunk|follow_redirect!|fork|form_for|form_tag|format|gets|global_variables|gsub|\" +\n        \"gsub!|get_via_redirect|host!|https?|https!|include|Integer|lambda|link_to|\" +\n        \"link_to_unless_current|link_to_function|link_to_remote|load|local_variables|loop|open|open_session|\" +\n        \"p|print|printf|proc|putc|puts|post_via_redirect|put_via_redirect|raise|rand|\" +\n        \"raw|readline|readlines|redirect?|request_via_redirect|acequire|scan|select|\" +\n        \"set_trace_func|sleep|split|sprintf|srand|String|stylesheet_link_tag|syscall|system|sub|sub!|test|\" +\n        \"throw|trace_var|trap|untrace_var|atan2|cos|exp|frexp|ldexp|log|log10|sin|sqrt|tan|\" +\n        \"render|javascript_include_tag|csrf_meta_tag|label_tag|text_field_tag|submit_tag|check_box_tag|\" +\n        \"content_tag|radio_button_tag|text_area_tag|password_field_tag|hidden_field_tag|\" +\n        \"fields_for|select_tag|options_for_select|options_from_collection_for_select|collection_select|\" +\n        \"time_zone_select|select_date|select_time|select_datetime|date_select|time_select|datetime_select|\" +\n        \"select_year|select_month|select_day|select_hour|select_minute|select_second|file_field_tag|\" +\n        \"file_field|respond_to|skip_before_filter|around_filter|after_filter|verify|\" +\n        \"protect_from_forgery|rescue_from|helper_method|redirect_to|before_filter|\" +\n        \"send_data|send_file|validates_presence_of|validates_uniqueness_of|validates_length_of|\" +\n        \"validates_format_of|validates_acceptance_of|validates_associated|validates_exclusion_of|\" +\n        \"validates_inclusion_of|validates_numericality_of|validates_with|validates_each|\" +\n        \"authenticate_or_request_with_http_basic|authenticate_or_request_with_http_digest|\" +\n        \"filter_parameter_logging|match|get|post|resources|redirect|scope|assert_routing|\" +\n        \"translate|localize|extract_locale_from_tld|caches_page|expire_page|caches_action|expire_action|\" +\n        \"cache|expire_fragment|expire_cache_for|observe|cache_sweeper|\" +\n        \"has_many|has_one|belongs_to|has_and_belongs_to_many\"\n    );\n\n    var keywords = (\n        \"alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|\" +\n        \"__FILE__|finally|for|gem|if|in|__LINE__|module|next|not|or|private|protected|public|\" +\n        \"redo|rescue|retry|return|super|then|undef|unless|until|when|while|yield\"\n    );\n\n    var buildinConstants = (\n        \"true|TRUE|false|FALSE|nil|NIL|ARGF|ARGV|DATA|ENV|RUBY_PLATFORM|RUBY_RELEASE_DATE|\" +\n        \"RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING\"\n    );\n\n    var builtinVariables = (\n        \"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" +\n        \"$!|root_url|flash|session|cookies|params|request|response|logger|self\"\n    );\n\n    var keywordMapper = this.$keywords = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"constant.language\": buildinConstants,\n        \"variable.language\": builtinVariables,\n        \"support.function\": builtinFunctions,\n        \"invalid.deprecated\": \"debugger\" // TODO is this a remnant from js mode?\n    }, \"identifier\");\n\n    this.$rules = {\n        \"start\" : [\n            {\n                token : \"comment\",\n                regex : \"#.*$\"\n            }, {\n                token : \"comment\", // multi line comment\n                regex : \"^=begin(?:$|\\\\s.*$)\",\n                next : \"comment\"\n            }, {\n                token : \"string.regexp\",\n                regex : \"[/](?:(?:\\\\[(?:\\\\\\\\]|[^\\\\]])+\\\\])|(?:\\\\\\\\/|[^\\\\]/]))*[/]\\\\w*\\\\s*(?=[).,;]|$)\"\n            },\n\n            [{\n                regex: \"[{}]\", onMatch: function(val, state, stack) {\n                    this.next = val == \"{\" ? this.nextState : \"\";\n                    if (val == \"{\" && stack.length) {\n                        stack.unshift(\"start\", state);\n                        return \"paren.lparen\";\n                    }\n                    if (val == \"}\" && stack.length) {\n                        stack.shift();\n                        this.next = stack.shift();\n                        if (this.next.indexOf(\"string\") != -1)\n                            return \"paren.end\";\n                    }\n                    return val == \"{\" ? \"paren.lparen\" : \"paren.rparen\";\n                },\n                nextState: \"start\"\n            }, {\n                token : \"string.start\",\n                regex : /\"/,\n                push  : [{\n                    token : \"constant.language.escape\",\n                    regex : /\\\\(?:[nsrtvfbae'\"\\\\]|c.|C-.|M-.(?:\\\\C-.)?|[0-7]{3}|x[\\da-fA-F]{2}|u[\\da-fA-F]{4})/\n                }, {\n                    token : \"paren.start\",\n                    regex : /#{/,\n                    push  : \"start\"\n                }, {\n                    token : \"string.end\",\n                    regex : /\"/,\n                    next  : \"pop\"\n                }, {\n                    defaultToken: \"string\"\n                }]\n            }, {\n                token : \"string.start\",\n                regex : /`/,\n                push  : [{\n                    token : \"constant.language.escape\",\n                    regex : /\\\\(?:[nsrtvfbae'\"\\\\]|c.|C-.|M-.(?:\\\\C-.)?|[0-7]{3}|x[\\da-fA-F]{2}|u[\\da-fA-F]{4})/\n                }, {\n                    token : \"paren.start\",\n                    regex : /#{/,\n                    push  : \"start\"\n                }, {\n                    token : \"string.end\",\n                    regex : /`/,\n                    next  : \"pop\"\n                }, {\n                    defaultToken: \"string\"\n                }]\n            }, {\n                token : \"string.start\",\n                regex : /'/,\n                push  : [{\n                    token : \"constant.language.escape\",\n                    regex : /\\\\['\\\\]/\n                },  {\n                    token : \"string.end\",\n                    regex : /'/,\n                    next  : \"pop\"\n                }, {\n                    defaultToken: \"string\"\n                }]\n            }],\n\n            {\n                token : \"text\", // namespaces aren't symbols\n                regex : \"::\"\n            }, {\n                token : \"variable.instance\", // instance variable\n                regex : \"@{1,2}[a-zA-Z_\\\\d]+\"\n            }, {\n                token : \"support.class\", // class name\n                regex : \"[A-Z][a-zA-Z_\\\\d]+\"\n            },\n\n            constantOtherSymbol,\n            constantNumericHex,\n            constantNumericFloat,\n\n            {\n                token : \"constant.language.boolean\",\n                regex : \"(?:true|false)\\\\b\"\n            }, {\n                token : keywordMapper,\n                regex : \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n            }, {\n                token : \"punctuation.separator.key-value\",\n                regex : \"=>\"\n            }, {\n                stateName: \"heredoc\",\n                onMatch : function(value, currentState, stack) {\n                    var next = value[2] == '-' ? \"indentedHeredoc\" : \"heredoc\";\n                    var tokens = value.split(this.splitRegex);\n                    stack.push(next, tokens[3]);\n                    return [\n                        {type:\"constant\", value: tokens[1]},\n                        {type:\"string\", value: tokens[2]},\n                        {type:\"support.class\", value: tokens[3]},\n                        {type:\"string\", value: tokens[4]}\n                    ];\n                },\n                regex : \"(<<-?)(['\\\"`]?)([\\\\w]+)(['\\\"`]?)\",\n                rules: {\n                    heredoc: [{\n                        onMatch:  function(value, currentState, stack) {\n                            if (value === stack[1]) {\n                                stack.shift();\n                                stack.shift();\n                                this.next = stack[0] || \"start\";\n                                return \"support.class\";\n                            }\n                            this.next = \"\";\n                            return \"string\";\n                        },\n                        regex: \".*$\",\n                        next: \"start\"\n                    }],\n                    indentedHeredoc: [{\n                        token: \"string\",\n                        regex: \"^ +\"\n                    }, {\n                        onMatch:  function(value, currentState, stack) {\n                            if (value === stack[1]) {\n                                stack.shift();\n                                stack.shift();\n                                this.next = stack[0] || \"start\";\n                                return \"support.class\";\n                            }\n                            this.next = \"\";\n                            return \"string\";\n                        },\n                        regex: \".*$\",\n                        next: \"start\"\n                    }]\n                }\n            }, {\n                regex : \"$\",\n                token : \"empty\",\n                next : function(currentState, stack) {\n                    if (stack[0] === \"heredoc\" || stack[0] === \"indentedHeredoc\")\n                        return stack[0];\n                    return currentState;\n                }\n            }, {\n               token : \"string.character\",\n               regex : \"\\\\B\\\\?.\"\n            }, {\n                token : \"keyword.operator\",\n                regex : \"!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\b(?:in|instanceof|new|delete|typeof|void)\"\n            }, {\n                token : \"paren.lparen\",\n                regex : \"[[({]\"\n            }, {\n                token : \"paren.rparen\",\n                regex : \"[\\\\])}]\"\n            }, {\n                token : \"text\",\n                regex : \"\\\\s+\"\n            }\n        ],\n        \"comment\" : [\n            {\n                token : \"comment\", // closing comment\n                regex : \"^=end(?:$|\\\\s.*$)\",\n                next : \"start\"\n            }, {\n                token : \"comment\", // comment spanning whole line\n                regex : \".+\"\n            }\n        ]\n    };\n\n    this.normalizeRules();\n};\n\noop.inherits(RubyHighlightRules, TextHighlightRules);\n\nexports.RubyHighlightRules = RubyHighlightRules;\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar Range = acequire(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\n\nace.define(\"ace/mode/folding/coffee\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../../lib/oop\");\nvar BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\nvar Range = acequire(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"#\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/ruby\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/ruby_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/range\",\"ace/mode/behaviour/cstyle\",\"ace/mode/folding/coffee\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextMode = acequire(\"./text\").Mode;\nvar RubyHighlightRules = acequire(\"./ruby_highlight_rules\").RubyHighlightRules;\nvar MatchingBraceOutdent = acequire(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar Range = acequire(\"../range\").Range;\nvar CstyleBehaviour = acequire(\"./behaviour/cstyle\").CstyleBehaviour;\nvar FoldMode = acequire(\"./folding/coffee\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = RubyHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = new CstyleBehaviour();\n    this.foldingRules = new FoldMode();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n\n    this.lineCommentStart = \"#\";\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n\n        if (tokens.length && tokens[tokens.length-1].type == \"comment\") {\n            return indent;\n        }\n\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n            var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n            var startingConditional = line.match(/^\\s*(if|else|when)\\s*/);\n            if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n                indent += tab;\n            }\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return /^\\s+(end|else)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, session, row) {\n        var line = session.getLine(row);\n        if (/}/.test(line))\n            return this.$outdent.autoOutdent(session, row);\n        var indent = this.$getIndent(line);\n        var prevLine = session.getLine(row - 1);\n        var prevIndent = this.$getIndent(prevLine);\n        var tab = session.getTabString();\n        if (prevIndent.length <= indent.length) {\n            if (indent.slice(-tab.length) == tab)\n                session.remove(new Range(row, indent.length-tab.length, row, indent.length));\n        }\n    };\n\n    this.$id = \"ace/mode/ruby\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n"],"sourceRoot":""}